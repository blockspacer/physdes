#pragma once

#include <boost/operators.hpp>

/**
 * @brief vector2
 *
 */
template <class T>
class vector2                      // note: private inheritance is OK here!
    : boost::field_operators<vector2<T>
    , boost::field_operators<vector2<T>, T // vector2 + vector2
    , boost::totally_ordered<vector2<T>
    > > >
{
  public:
    vector2(T x, T y) : _x{std::move(x)}, _y{std::move(y)} {}

    T x() const { return _x; }
    T y() const { return _y; };

    vector2& operator+=(const vector2& rhs)
    {
        this->_x += rhs.x();
        this->_y += rhs.y();
        return *this;
    }

    // vector2 operator+(vector2, const vector2&) automatically
    // generated by addable.

    vector2& operator-=(const vector2& rhs)
    {
        this->_x -= rhs.x();
        this->_y -= rhs.y();
        return *this;
    }

    // vector2 operator-(vector2, const vector2&) automatically
    // generated by subtractable.

    vector2& operator*=(const T& alpha)
    {
        this->_x *= alpha;
        this->_y *= alpha;
        return *this;
    }

    // vector2 operator*(vector2, const T&) and
    // vector2 operator*(const T&, vector2) auto-generated
    // by multipliable.

    vector2& operator/=(const T& alpha)
    {
        this->_x /= alpha;
        this->_y /= alpha;
        return *this;
    }

    // vector2 operator/(vector2, const T&) auto-generated
    // by dividable.

    bool operator==(const vector2<T>& rhs) const
    {
        return this->_x == rhs._x && this->_y == rhs._y;
    }

    // vector2 operator!=(vector2, const T&) auto-generated
    // by equal_comparable.

  private:
    T _x;
    T _y;
};
